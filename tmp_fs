import { env } from "../env";
import { prisma } from "../database/client";
import type { File as FileModel } from "@prisma/client";

export type FileRecord = {
  token: string;
  storageKey: string;
  originalName: string;
  mimeType: string;
  size: number;
  createdAt: Date;
  expiresAt: Date;
  maxDownloads: number;
  downloadCount: number;
  isDeleted: boolean;
};

export type FileInfoDTO = {
  token: string;
  originalName: string;
  mimeType: string;
  size: number;
  createdAt: Date;
  expiresAt: Date;
  downloadCount: number;
  maxDownloads: number;
  remainingDownloads: number;
  status: 'active' | 'expired' | 'deleted';
};

function isExpiredDate(d: Date): boolean {
  return d.getTime() <= Date.now();
}

function mapDbToRecord(row: FileModel): FileRecord {
  return {
    token: row.token,
    storageKey: row.storagePath,
    originalName: row.originalName,
    mimeType: row.mimeType,
    size: Number(row.fileSize),
    createdAt: row.createdAt,
    expiresAt: row.expiresAt,
    maxDownloads: row.maxDownloads,
    downloadCount: row.downloadCount,
    isDeleted: row.isDeleted,
  };
}

export async function create(input: {
  token: string;
  storageKey?: string;
  storagePath?: string;
  originalName: string;
  mimeType: string;
  size: number;
  expiresAt?: Date;
  expiresInMs?: number;
  maxDownloads?: number;
}): Promise<FileRecord> {
  const token = input.token;
  const expiresAt = input.expiresAt ?? new Date(Date.now() + (input.expiresInMs ?? env.DEFAULT_EXPIRY_HOURS * 60 * 60 * 1000));
  const storagePath = input.storageKey ?? input.storagePath ?? '';

  try {
    const row = await prisma.file.create({
      data: {
        token,
        originalName: input.originalName,
        fileSize: BigInt(input.size),
        mimeType: input.mimeType,
        storagePath,
        expiresAt,
        maxDownloads: input.maxDownloads ?? env.DEFAULT_MAX_DOWNLOADS,
      },
    });
    return mapDbToRecord(row);
  } catch (err: any) {
    if (err && err.code === 'P2002') {
      throw new Error('TOKEN_CONFLICT');
    }
    throw err;
  }
}

export async function get(token: string): Promise<FileRecord | null> {
  const row = await prisma.file.findUnique({ where: { token } });
  if (!row) return null;
  return mapDbToRecord(row);
}

export async function getInfo(token: string): Promise<FileInfoDTO | null> {
  const row = await prisma.file.findUnique({ where: { token } });
  if (!row) return null;
  const status: FileInfoDTO['status'] = row.isDeleted ? 'deleted' : isExpiredDate(row.expiresAt) ? 'expired' : 'active';
  return {
    token: row.token,
    originalName: row.originalName,
    mimeType: row.mimeType,
    size: Number(row.fileSize),
    createdAt: row.createdAt,
    expiresAt: row.expiresAt,
    downloadCount: row.downloadCount,
    maxDownloads: row.maxDownloads,
    remainingDownloads: Math.max(row.maxDownloads - row.downloadCount, 0),
    status,
  };
}

export async function consumeDownload(token: string): Promise<{ record: FileRecord; shouldDelete: boolean } | null> {
  const rows = await prisma.$queryRaw<FileModel[]>`
      UPDATE "files"
      SET "downloadCount" = "downloadCount" + 1
      WHERE "token" = ${token}
        AND NOT "isDeleted"
        AND "expiresAt" > NOW()
        AND "downloadCount" < "maxDownloads"
      RETURNING *
    `;
  if (!rows || rows.length === 0) {
    return null;
  }
  const updated = rows[0];
  const record = mapDbToRecord(updated);
  const shouldDelete = record.downloadCount >= record.maxDownloads;
  return { record, shouldDelete };
}

export async function markDeleted(token: string): Promise<void> {
  try {
    await prisma.file.update({ where: { token }, data: { isDeleted: true } });
  } catch (err: any) {
    if (err && err.code === 'P2025') return;
    throw err;
  }
}
